/**
 * \file
 *
 * \brief Empty user application template
 *
 */

/**
 * \mainpage User Application template doxygen documentation
 *
 * \par Empty user application template
 *
 * Bare minimum empty user application template
 *
 * \par Content
 *
 * -# Include the ASF header files (through asf.h)
 * -# "Insert system clock initialization code here" comment
 * -# Minimal main function that starts with a call to board_init()
 * -# "Insert application code here" comment
 *
 */

/*
 * Include header files for all drivers that have been imported from
 * Atmel Software Framework (ASF).
 */
/*
 * Support and FAQ: visit <a href="http://www.atmel.com/design-support/">Atmel Support</a>
 */
#include "asf.h"
#define F_CPU 16000000UL
#include <avr/io.h>
#include "uart.h"
#include <util/delay.h>
#include <avr/interrupt.h>
#include <avr/pgmspace.h>
#include <string.h>
#define OLED_CONTROL_PORT_DDR DDRB
#define OLED_CONTROL_PORT PORTB
#define OLED_DC PORTB0
#define OLED_CS PORTB1
#define OLED_WR PORTD7
#define OLED_COL_START 0x1C
#define OLED_COL_END 0x5B
#define OLED_ROW_START 0x00
#define OLED_ROW_END 0x3f
#define BUFF_LENGTH 10 //length of buffers in respect to bytes
FILE uart_str = FDEV_SETUP_STREAM(uart_putchar, uart_getchar, _FDEV_SETUP_RW);
char rec[256]; // Declare a character buffer

const unsigned char font8x8_basic[128][8] = {
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0000 (nul)
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0001
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0002
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0003
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0004
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0005
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0006
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0007
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0008
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0009
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+000A
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+000B
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+000C
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+000D
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+000E
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+000F
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0010
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0011
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0012
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0013
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0014
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0015
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0016
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0017
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0018
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0019
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+001A
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+001B
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+001C
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+001D
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+001E
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+001F
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0020 (space)
	{ 0x18, 0x3C, 0x3C, 0x18, 0x18, 0x00, 0x18, 0x00},   // U+0021 (!)
	{ 0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0022 (")
	{ 0x36, 0x36, 0x7F, 0x36, 0x7F, 0x36, 0x36, 0x00},   // U+0023 (#)
	{ 0x0C, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x0C, 0x00},   // U+0024 ($)
	{ 0x00, 0x63, 0x33, 0x18, 0x0C, 0x66, 0x63, 0x00},   // U+0025 (%)
	{ 0x1C, 0x36, 0x1C, 0x6E, 0x3B, 0x33, 0x6E, 0x00},   // U+0026 (&)
	{ 0x06, 0x06, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0027 (')
	{ 0x18, 0x0C, 0x06, 0x06, 0x06, 0x0C, 0x18, 0x00},   // U+0028 (()
	{ 0x06, 0x0C, 0x18, 0x18, 0x18, 0x0C, 0x06, 0x00},   // U+0029 ())
	{ 0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00},   // U+002A (*)
	{ 0x00, 0x0C, 0x0C, 0x3F, 0x0C, 0x0C, 0x00, 0x00},   // U+002B (+)
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x06},   // U+002C (,)
	{ 0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00},   // U+002D (-)
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x00},   // U+002E (.)
	{ 0x60, 0x30, 0x18, 0x0C, 0x06, 0x03, 0x01, 0x00},   // U+002F (/)
	{ 0x3E, 0x63, 0x73, 0x7B, 0x6F, 0x67, 0x3E, 0x00},   // U+0030 (0)
	{ 0x0C, 0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x3F, 0x00},   // U+0031 (1)
	{ 0x1E, 0x33, 0x30, 0x1C, 0x06, 0x33, 0x3F, 0x00},   // U+0032 (2)
	{ 0x1E, 0x33, 0x30, 0x1C, 0x30, 0x33, 0x1E, 0x00},   // U+0033 (3)
	{ 0x38, 0x3C, 0x36, 0x33, 0x7F, 0x30, 0x78, 0x00},   // U+0034 (4)
	{ 0x3F, 0x03, 0x1F, 0x30, 0x30, 0x33, 0x1E, 0x00},   // U+0035 (5)
	{ 0x1C, 0x06, 0x03, 0x1F, 0x33, 0x33, 0x1E, 0x00},   // U+0036 (6)
	{ 0x3F, 0x33, 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x00},   // U+0037 (7)
	{ 0x1E, 0x33, 0x33, 0x1E, 0x33, 0x33, 0x1E, 0x00},   // U+0038 (8)
	{ 0x1E, 0x33, 0x33, 0x3E, 0x30, 0x18, 0x0E, 0x00},   // U+0039 (9)
	{ 0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x00},   // U+003A (:)
	{ 0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x06},   // U+003B (//)
	{ 0x18, 0x0C, 0x06, 0x03, 0x06, 0x0C, 0x18, 0x00},   // U+003C (<)
	{ 0x00, 0x00, 0x3F, 0x00, 0x00, 0x3F, 0x00, 0x00},   // U+003D (=)
	{ 0x06, 0x0C, 0x18, 0x30, 0x18, 0x0C, 0x06, 0x00},   // U+003E (>)
	{ 0x1E, 0x33, 0x30, 0x18, 0x0C, 0x00, 0x0C, 0x00},   // U+003F (?)
	{ 0x3E, 0x63, 0x7B, 0x7B, 0x7B, 0x03, 0x1E, 0x00},   // U+0040 (@)
	{ 0x0C, 0x1E, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x00},   // U+0041 (A)
	{ 0x3F, 0x66, 0x66, 0x3E, 0x66, 0x66, 0x3F, 0x00},   // U+0042 (B)
	{ 0x3C, 0x66, 0x03, 0x03, 0x03, 0x66, 0x3C, 0x00},   // U+0043 (C)
	{ 0x1F, 0x36, 0x66, 0x66, 0x66, 0x36, 0x1F, 0x00},   // U+0044 (D)
	{ 0x7F, 0x46, 0x16, 0x1E, 0x16, 0x46, 0x7F, 0x00},   // U+0045 (E)
	{ 0x7F, 0x46, 0x16, 0x1E, 0x16, 0x06, 0x0F, 0x00},   // U+0046 (F)
	{ 0x3C, 0x66, 0x03, 0x03, 0x73, 0x66, 0x7C, 0x00},   // U+0047 (G)
	{ 0x33, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x33, 0x00},   // U+0048 (H)
	{ 0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},   // U+0049 (I)
	{ 0x78, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E, 0x00},   // U+004A (J)
	{ 0x67, 0x66, 0x36, 0x1E, 0x36, 0x66, 0x67, 0x00},   // U+004B (K)
	{ 0x0F, 0x06, 0x06, 0x06, 0x46, 0x66, 0x7F, 0x00},   // U+004C (L)
	{ 0x63, 0x77, 0x7F, 0x7F, 0x6B, 0x63, 0x63, 0x00},   // U+004D (M)
	{ 0x63, 0x67, 0x6F, 0x7B, 0x73, 0x63, 0x63, 0x00},   // U+004E (N)
	{ 0x1C, 0x36, 0x63, 0x63, 0x63, 0x36, 0x1C, 0x00},   // U+004F (O)
	{ 0x3F, 0x66, 0x66, 0x3E, 0x06, 0x06, 0x0F, 0x00},   // U+0050 (P)
	{ 0x1E, 0x33, 0x33, 0x33, 0x3B, 0x1E, 0x38, 0x00},   // U+0051 (Q)
	{ 0x3F, 0x66, 0x66, 0x3E, 0x36, 0x66, 0x67, 0x00},   // U+0052 (R)
	{ 0x1E, 0x33, 0x07, 0x0E, 0x38, 0x33, 0x1E, 0x00},   // U+0053 (S)
	{ 0x3F, 0x2D, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},   // U+0054 (T)
	{ 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x3F, 0x00},   // U+0055 (U)
	{ 0x33, 0x33, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00},   // U+0056 (V)
	{ 0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x00},   // U+0057 (W)
	{ 0x63, 0x63, 0x36, 0x1C, 0x1C, 0x36, 0x63, 0x00},   // U+0058 (X)
	{ 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x0C, 0x1E, 0x00},   // U+0059 (Y)
	{ 0x7F, 0x63, 0x31, 0x18, 0x4C, 0x66, 0x7F, 0x00},   // U+005A (Z)
	{ 0x1E, 0x06, 0x06, 0x06, 0x06, 0x06, 0x1E, 0x00},   // U+005B ([)
	{ 0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x40, 0x00},   // U+005C (\)
	{ 0x1E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1E, 0x00},   // U+005D (])
	{ 0x08, 0x1C, 0x36, 0x63, 0x00, 0x00, 0x00, 0x00},   // U+005E (^)
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF},   // U+005F (_)
	{ 0x0C, 0x0C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0060 (`)
	{ 0x00, 0x00, 0x1E, 0x30, 0x3E, 0x33, 0x6E, 0x00},   // U+0061 (a)
	{ 0x07, 0x06, 0x06, 0x3E, 0x66, 0x66, 0x3B, 0x00},   // U+0062 (b)
	{ 0x00, 0x00, 0x1E, 0x33, 0x03, 0x33, 0x1E, 0x00},   // U+0063 (c)
	{ 0x38, 0x30, 0x30, 0x3e, 0x33, 0x33, 0x6E, 0x00},   // U+0064 (d)
	{ 0x00, 0x00, 0x1E, 0x33, 0x3f, 0x03, 0x1E, 0x00},   // U+0065 (e)
	{ 0x1C, 0x36, 0x06, 0x0f, 0x06, 0x06, 0x0F, 0x00},   // U+0066 (f)
	{ 0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x1F},   // U+0067 (g)
	{ 0x07, 0x06, 0x36, 0x6E, 0x66, 0x66, 0x67, 0x00},   // U+0068 (h)
	{ 0x0C, 0x00, 0x0E, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},   // U+0069 (i)
	{ 0x30, 0x00, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E},   // U+006A (j)
	{ 0x07, 0x06, 0x66, 0x36, 0x1E, 0x36, 0x67, 0x00},   // U+006B (k)
	{ 0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},   // U+006C (l)
	{ 0x00, 0x00, 0x33, 0x7F, 0x7F, 0x6B, 0x63, 0x00},   // U+006D (m)
	{ 0x00, 0x00, 0x1F, 0x33, 0x33, 0x33, 0x33, 0x00},   // U+006E (n)
	{ 0x00, 0x00, 0x1E, 0x33, 0x33, 0x33, 0x1E, 0x00},   // U+006F (o)
	{ 0x00, 0x00, 0x3B, 0x66, 0x66, 0x3E, 0x06, 0x0F},   // U+0070 (p)
	{ 0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x78},   // U+0071 (q)
	{ 0x00, 0x00, 0x3B, 0x6E, 0x66, 0x06, 0x0F, 0x00},   // U+0072 (r)
	{ 0x00, 0x00, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x00},   // U+0073 (s)
	{ 0x08, 0x0C, 0x3E, 0x0C, 0x0C, 0x2C, 0x18, 0x00},   // U+0074 (t)
	{ 0x00, 0x00, 0x33, 0x33, 0x33, 0x33, 0x6E, 0x00},   // U+0075 (u)
	{ 0x00, 0x00, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00},   // U+0076 (v)
	{ 0x00, 0x00, 0x63, 0x6B, 0x7F, 0x7F, 0x36, 0x00},   // U+0077 (w)
	{ 0x00, 0x00, 0x63, 0x36, 0x1C, 0x36, 0x63, 0x00},   // U+0078 (x)
	{ 0x00, 0x00, 0x33, 0x33, 0x33, 0x3E, 0x30, 0x1F},   // U+0079 (y)
	{ 0x00, 0x00, 0x3F, 0x19, 0x0C, 0x26, 0x3F, 0x00},   // U+007A (z)
	{ 0x38, 0x0C, 0x0C, 0x07, 0x0C, 0x0C, 0x38, 0x00},   // U+007B ({)
	{ 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00},   // U+007C (|)
	{ 0x07, 0x0C, 0x0C, 0x38, 0x0C, 0x0C, 0x07, 0x00},   // U+007D (})
	{ 0x6E, 0x3B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+007E (~)
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}    // U+007F
};
//#include "SRAM.h" //custom SRAM library
/* * Port/Signals Definitions for SRAM */
volatile uint8_t test;
uint16_t row = 0x00; //start at row 0
uint16_t col = 0x1c; //start at col 0
uint8_t write_buffer[BUFF_LENGTH] = {0xa0,0,0,0,0,0,0,0,0,0};
uint8_t read_buffer[BUFF_LENGTH];
void OLED_Config_Data_Port_Output(){
	DDRC |= 0x3f; //data port config 
	DDRD |= 0x0c;
	PORTC &= ~(0x3f);
	PORTD &= ~(0x0c);
}
void OLED_Config_Control_Port(){
	DDRD |= (1<<OLED_WR) | (1<<PORTD6);
	PORTD |= (1<<OLED_WR) | (1<<PORTD6);
	OLED_CONTROL_PORT_DDR |= (0x07);
	OLED_CONTROL_PORT |= ( (1<<OLED_DC) | (1<<OLED_CS));
}
void OLED_Write_Command(uint8_t cmd, uint8_t data, uint8_t data1, uint8_t select){
	PORTC &= ~(0x3f);
	PORTD &= ~(0x0c);//clear ports
	PORTC |= (0x3f & cmd);
	PORTD |= (0x0c &(cmd >> 4)); //align data
	OLED_CONTROL_PORT &= ~(1<<OLED_DC);
	OLED_CONTROL_PORT &= ~(1<<OLED_CS); //pull cs low for command option and enable chip
	PORTD &= ~(1<<OLED_WR);
	PORTD |= (1<<OLED_WR); //latch command
	if (select>0){ //latch data if select isnt 0 
		PORTC &= ~(0x3f); //clear port
		PORTD &= ~(0x0c);
		PORTC |= (0x3f & data);
		PORTD |= (0x0c &(data >> 4)); //align new data
		OLED_CONTROL_PORT |= (1<<OLED_DC); //set to data mode
		PORTD &= ~(1<<OLED_WR);
		PORTD |= (1<<OLED_WR); //latch command
		if(select > 1){ //latch data 1 if select is greater than 1
			PORTC &= ~(0x3f); //clear port
			PORTD &= ~(0x0c);
			PORTC |= (0x3f & data1);
			PORTD |= (0x0c &(data1 >> 4)); //align new data
			PORTD &= ~(1<<OLED_WR);
			PORTD |= (1<<OLED_WR); //latch command
		}
	}
	OLED_CONTROL_PORT |= (1<<OLED_CS); //end command
}
void OLED_Write_Command_only(uint8_t cmd){
	PORTC &= ~(0x3f);
	PORTD &= ~(0x0c);//clear ports
	PORTC |= (0x3f & cmd);
	PORTD |= (0x0c &(cmd >> 4)); //align data
	OLED_CONTROL_PORT &= ~(1<<OLED_DC);
	OLED_CONTROL_PORT &= ~(1<<OLED_CS); //pull cs low for command option and enable chip
	PORTD &= ~(1<<OLED_WR);
	PORTD |= (1<<OLED_WR); //latch command
}
void OLED_Write_Data(uint8_t data){
	PORTC &= ~(0x3f); //clear port
	PORTD &= ~(0x0c);
	PORTC |= (0x3f & data);
	PORTD |= (0x0c &(data >> 4)); //align new data
	OLED_CONTROL_PORT |= (1<<OLED_DC); //set to data mode
	PORTD &= ~(1<<OLED_WR);
	PORTD |= (1<<OLED_WR); //latch command
}
void OLED_Print_Character8x8(uint8_t data, uint16_t x, uint16_t y){ //INDEXING STARTS AT 0,0
	uint8_t control_mask = 0b10000000;
	int inc = row;
	uint8_t packet = 0x00;
	OLED_Write_Command(0x15,0x1c+x,0x5b,1); // set column adress
	OLED_Write_Command(0x75,inc+y,0x3f,1); // set row adress
	for(int i = 0; i <= 7; i++){
		OLED_Write_Command_only(0x5c);
		if(control_mask & font8x8_basic[data][i]){
			packet |= 0xf0;
		}
		control_mask = 0b00000001;
		if(control_mask & font8x8_basic[data][i]){
			packet |= 0x0f;
		}
		control_mask = control_mask * 2;
		OLED_Write_Data(packet);
		packet = 0x00;
		if(control_mask & font8x8_basic[data][i]){
			packet |= 0xf0;
		}
		control_mask = control_mask * 2;
		if(control_mask & font8x8_basic[data][i]){
			packet |= 0x0f;
		}
		control_mask = control_mask * 2;
		OLED_Write_Data(packet);
		packet = 0x00;
		if(control_mask & font8x8_basic[data][i]){
			packet |= 0xf0;
		}
		control_mask = control_mask * 2;
		if(control_mask & font8x8_basic[data][i]){
			packet |= 0x0f;
		}
		control_mask = control_mask * 2;
		OLED_Write_Data(packet);
		packet = 0x00;
		if(control_mask & font8x8_basic[data][i]){
			packet |= 0xf0;
		}
		control_mask = control_mask * 2;
		if(control_mask & font8x8_basic[data][i]){
			packet |= 0x0f;
		}
		control_mask = control_mask * 2;
		OLED_Write_Data(packet);
		packet = 0x00;
	   OLED_CONTROL_PORT |= (1<<OLED_CS);
	   inc++;
	   OLED_Write_Command(0x15,0x1c+x,0x5b,2); // set column adress
	   OLED_Write_Command(0x75,inc+y,0x3f,1); // set row adress
	}
}
void OLED_Print_String(char* _string, uint16_t x, uint16_t y ){
	for(int i = 0; i <= strlen(_string); i++){
		OLED_Print_Character8x8(_string[i], i*2 + x, y);
	}
}
void SPI_MasterInit(void)
{
	/* Set SS, MOSI and SCK output, all others input */
	DDRB = (1<<PORTB2) | (1<<PORTB3) | (1<<PORTB5);
	/* Enable SPI, Master, set clock rate fck/128 */
	SPCR = (1<<SPE) | (1<<MSTR) | (1<<SPR1) | (1<<SPR0);
	PORTB |= (1<<PORTB2);
}
uint8_t SPI_Master_Transceive(uint8_t cData)
{
	PORTB &= ~(1<<PORTB2); // Pull Slave_Select low
	SPDR = cData; // Start transmission
	while( !(SPSR & (1<<SPIF)) ); // Wait for transmission complete
	PORTB |= (1<<PORTB2); // Pull Slave Select High
	return SPDR; // Return received data
}
void SPI_Master_Traceive_Buffer(uint8_t *wd_buffer, uint8_t *rd_buffer, uint8_t size){
	PORTB &= ~(1<<PORTB2); // Pull Slave_Select low
	for(int i = 0; i < size; i++){
		SPDR = wd_buffer[i];
		while( !(SPSR & (1<<SPIF)) ); // Wait for transmission complete
		rd_buffer[i] = SPDR;
	}
	PORTB |= (1<<PORTB2); // Pull Slave Select High
}
int main (void)
{
	board_init();
	SPI_MasterInit();
	OLED_Config_Data_Port_Output();
	OLED_Config_Control_Port();
	OLED_Write_Command(0xFD,0x12,0x00,1); // unlock oled
	OLED_Write_Command(0xa4,0x00,0x00,0); // turn off display
	OLED_Write_Command(0x15,0x1c,0x5b,2); // set column adress
	OLED_Write_Command(0x75,0x00,0x3f,2); // set row adress
	OLED_Write_Command(0xb3,0x91,0x00,1); // set clock
	OLED_Write_Command(0xCA,0x3f,0x00,1); // set multiplex
	OLED_Write_Command(0xa2,0x00,0x00,1); // display offset
	OLED_Write_Command(0xa1,0x00,0x00,1); // display start line
	OLED_Write_Command(0xa0,0x00,0x00,0); // remap
	OLED_Write_Command(0xb5,0x00,0x00,1); // disable gpio
	OLED_Write_Command(0xAB,0x01,0x00,0); // function selection
	OLED_Write_Command(0xb4,0xa0,0xfd,2); // ehancement a
	OLED_Write_Command(0xc1,0x9f,0x00,1); // contrast current 
	OLED_Write_Command(0xc7,0x0f,0x00,1); // master current
	OLED_Write_Command(0xb9,0x00,0x00,0); // select default linear grey scale table
	OLED_Write_Command(0xb1,0xe2,0x00,1); // phase length
	OLED_Write_Command(0xd1,0x20,0x00,1); // display enhancement b
	OLED_Write_Command(0xbb,0x1f,0x00,1); // pre charge voltage
	OLED_Write_Command(0xb6,0x08,0x00,1); // pre charge period
	OLED_Write_Command(0xbe,0x07,0x00,1); // set VCOMH
	OLED_Write_Command(0xa6,0x00,0x00,0); // display in normal mode
	char* teststring= "this is a test";
	uart_init();
	stdout = stdin = stderr = &uart_str; // Set File outputs to point to UART stream
	fprintf(stdout, "Hello! \n");
	int x = 0;
	int y = 0;
	while(1)
	{
		fscanf(stdin,"%s",rec);
		if(rec[0] == 0x44 && rec[1] == 0x53 && rec[2] == 0x52){
			
		}
		if(rec[0] != 0){
			for(int i = 0; rec[i] != 0; i++){
				OLED_Print_Character8x8(rec[i],x,y);
				x = x + 2;
				if(x >= 64){
					x = 0;
					y = y + 8;
				}
			}
			OLED_Print_Character8x8(0x20,x,y);
			x = x + 1;
		}
		
	}
}
